// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'case_analysis.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$CaseAnalysis {

 StructuredProblemSolving get structuredProblemSolving; BusinessJudgment get businessJudgment; QuantitativeSkills get quantitativeSkills; Communication get communication; SanityCheck get sanityCheck; double get overallWeightedScore; String get overallLabel; List<PriorityImprovement> get priorityImprovements; List<String> get highlights;
/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CaseAnalysisCopyWith<CaseAnalysis> get copyWith => _$CaseAnalysisCopyWithImpl<CaseAnalysis>(this as CaseAnalysis, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CaseAnalysis&&(identical(other.structuredProblemSolving, structuredProblemSolving) || other.structuredProblemSolving == structuredProblemSolving)&&(identical(other.businessJudgment, businessJudgment) || other.businessJudgment == businessJudgment)&&(identical(other.quantitativeSkills, quantitativeSkills) || other.quantitativeSkills == quantitativeSkills)&&(identical(other.communication, communication) || other.communication == communication)&&(identical(other.sanityCheck, sanityCheck) || other.sanityCheck == sanityCheck)&&(identical(other.overallWeightedScore, overallWeightedScore) || other.overallWeightedScore == overallWeightedScore)&&(identical(other.overallLabel, overallLabel) || other.overallLabel == overallLabel)&&const DeepCollectionEquality().equals(other.priorityImprovements, priorityImprovements)&&const DeepCollectionEquality().equals(other.highlights, highlights));
}


@override
int get hashCode => Object.hash(runtimeType,structuredProblemSolving,businessJudgment,quantitativeSkills,communication,sanityCheck,overallWeightedScore,overallLabel,const DeepCollectionEquality().hash(priorityImprovements),const DeepCollectionEquality().hash(highlights));

@override
String toString() {
  return 'CaseAnalysis(structuredProblemSolving: $structuredProblemSolving, businessJudgment: $businessJudgment, quantitativeSkills: $quantitativeSkills, communication: $communication, sanityCheck: $sanityCheck, overallWeightedScore: $overallWeightedScore, overallLabel: $overallLabel, priorityImprovements: $priorityImprovements, highlights: $highlights)';
}


}

/// @nodoc
abstract mixin class $CaseAnalysisCopyWith<$Res>  {
  factory $CaseAnalysisCopyWith(CaseAnalysis value, $Res Function(CaseAnalysis) _then) = _$CaseAnalysisCopyWithImpl;
@useResult
$Res call({
 StructuredProblemSolving structuredProblemSolving, BusinessJudgment businessJudgment, QuantitativeSkills quantitativeSkills, Communication communication, SanityCheck sanityCheck, double overallWeightedScore, String overallLabel, List<PriorityImprovement> priorityImprovements, List<String> highlights
});


$StructuredProblemSolvingCopyWith<$Res> get structuredProblemSolving;$BusinessJudgmentCopyWith<$Res> get businessJudgment;$QuantitativeSkillsCopyWith<$Res> get quantitativeSkills;$CommunicationCopyWith<$Res> get communication;$SanityCheckCopyWith<$Res> get sanityCheck;

}
/// @nodoc
class _$CaseAnalysisCopyWithImpl<$Res>
    implements $CaseAnalysisCopyWith<$Res> {
  _$CaseAnalysisCopyWithImpl(this._self, this._then);

  final CaseAnalysis _self;
  final $Res Function(CaseAnalysis) _then;

/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? structuredProblemSolving = null,Object? businessJudgment = null,Object? quantitativeSkills = null,Object? communication = null,Object? sanityCheck = null,Object? overallWeightedScore = null,Object? overallLabel = null,Object? priorityImprovements = null,Object? highlights = null,}) {
  return _then(_self.copyWith(
structuredProblemSolving: null == structuredProblemSolving ? _self.structuredProblemSolving : structuredProblemSolving // ignore: cast_nullable_to_non_nullable
as StructuredProblemSolving,businessJudgment: null == businessJudgment ? _self.businessJudgment : businessJudgment // ignore: cast_nullable_to_non_nullable
as BusinessJudgment,quantitativeSkills: null == quantitativeSkills ? _self.quantitativeSkills : quantitativeSkills // ignore: cast_nullable_to_non_nullable
as QuantitativeSkills,communication: null == communication ? _self.communication : communication // ignore: cast_nullable_to_non_nullable
as Communication,sanityCheck: null == sanityCheck ? _self.sanityCheck : sanityCheck // ignore: cast_nullable_to_non_nullable
as SanityCheck,overallWeightedScore: null == overallWeightedScore ? _self.overallWeightedScore : overallWeightedScore // ignore: cast_nullable_to_non_nullable
as double,overallLabel: null == overallLabel ? _self.overallLabel : overallLabel // ignore: cast_nullable_to_non_nullable
as String,priorityImprovements: null == priorityImprovements ? _self.priorityImprovements : priorityImprovements // ignore: cast_nullable_to_non_nullable
as List<PriorityImprovement>,highlights: null == highlights ? _self.highlights : highlights // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}
/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$StructuredProblemSolvingCopyWith<$Res> get structuredProblemSolving {
  
  return $StructuredProblemSolvingCopyWith<$Res>(_self.structuredProblemSolving, (value) {
    return _then(_self.copyWith(structuredProblemSolving: value));
  });
}/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BusinessJudgmentCopyWith<$Res> get businessJudgment {
  
  return $BusinessJudgmentCopyWith<$Res>(_self.businessJudgment, (value) {
    return _then(_self.copyWith(businessJudgment: value));
  });
}/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$QuantitativeSkillsCopyWith<$Res> get quantitativeSkills {
  
  return $QuantitativeSkillsCopyWith<$Res>(_self.quantitativeSkills, (value) {
    return _then(_self.copyWith(quantitativeSkills: value));
  });
}/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommunicationCopyWith<$Res> get communication {
  
  return $CommunicationCopyWith<$Res>(_self.communication, (value) {
    return _then(_self.copyWith(communication: value));
  });
}/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SanityCheckCopyWith<$Res> get sanityCheck {
  
  return $SanityCheckCopyWith<$Res>(_self.sanityCheck, (value) {
    return _then(_self.copyWith(sanityCheck: value));
  });
}
}


/// Adds pattern-matching-related methods to [CaseAnalysis].
extension CaseAnalysisPatterns on CaseAnalysis {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _CaseAnalysis value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _CaseAnalysis() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _CaseAnalysis value)  $default,){
final _that = this;
switch (_that) {
case _CaseAnalysis():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _CaseAnalysis value)?  $default,){
final _that = this;
switch (_that) {
case _CaseAnalysis() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( StructuredProblemSolving structuredProblemSolving,  BusinessJudgment businessJudgment,  QuantitativeSkills quantitativeSkills,  Communication communication,  SanityCheck sanityCheck,  double overallWeightedScore,  String overallLabel,  List<PriorityImprovement> priorityImprovements,  List<String> highlights)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _CaseAnalysis() when $default != null:
return $default(_that.structuredProblemSolving,_that.businessJudgment,_that.quantitativeSkills,_that.communication,_that.sanityCheck,_that.overallWeightedScore,_that.overallLabel,_that.priorityImprovements,_that.highlights);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( StructuredProblemSolving structuredProblemSolving,  BusinessJudgment businessJudgment,  QuantitativeSkills quantitativeSkills,  Communication communication,  SanityCheck sanityCheck,  double overallWeightedScore,  String overallLabel,  List<PriorityImprovement> priorityImprovements,  List<String> highlights)  $default,) {final _that = this;
switch (_that) {
case _CaseAnalysis():
return $default(_that.structuredProblemSolving,_that.businessJudgment,_that.quantitativeSkills,_that.communication,_that.sanityCheck,_that.overallWeightedScore,_that.overallLabel,_that.priorityImprovements,_that.highlights);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( StructuredProblemSolving structuredProblemSolving,  BusinessJudgment businessJudgment,  QuantitativeSkills quantitativeSkills,  Communication communication,  SanityCheck sanityCheck,  double overallWeightedScore,  String overallLabel,  List<PriorityImprovement> priorityImprovements,  List<String> highlights)?  $default,) {final _that = this;
switch (_that) {
case _CaseAnalysis() when $default != null:
return $default(_that.structuredProblemSolving,_that.businessJudgment,_that.quantitativeSkills,_that.communication,_that.sanityCheck,_that.overallWeightedScore,_that.overallLabel,_that.priorityImprovements,_that.highlights);case _:
  return null;

}
}

}

/// @nodoc


class _CaseAnalysis implements CaseAnalysis {
  const _CaseAnalysis({required this.structuredProblemSolving, required this.businessJudgment, required this.quantitativeSkills, required this.communication, required this.sanityCheck, required this.overallWeightedScore, required this.overallLabel, required final  List<PriorityImprovement> priorityImprovements, required final  List<String> highlights}): _priorityImprovements = priorityImprovements,_highlights = highlights;
  

@override final  StructuredProblemSolving structuredProblemSolving;
@override final  BusinessJudgment businessJudgment;
@override final  QuantitativeSkills quantitativeSkills;
@override final  Communication communication;
@override final  SanityCheck sanityCheck;
@override final  double overallWeightedScore;
@override final  String overallLabel;
 final  List<PriorityImprovement> _priorityImprovements;
@override List<PriorityImprovement> get priorityImprovements {
  if (_priorityImprovements is EqualUnmodifiableListView) return _priorityImprovements;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_priorityImprovements);
}

 final  List<String> _highlights;
@override List<String> get highlights {
  if (_highlights is EqualUnmodifiableListView) return _highlights;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_highlights);
}


/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CaseAnalysisCopyWith<_CaseAnalysis> get copyWith => __$CaseAnalysisCopyWithImpl<_CaseAnalysis>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CaseAnalysis&&(identical(other.structuredProblemSolving, structuredProblemSolving) || other.structuredProblemSolving == structuredProblemSolving)&&(identical(other.businessJudgment, businessJudgment) || other.businessJudgment == businessJudgment)&&(identical(other.quantitativeSkills, quantitativeSkills) || other.quantitativeSkills == quantitativeSkills)&&(identical(other.communication, communication) || other.communication == communication)&&(identical(other.sanityCheck, sanityCheck) || other.sanityCheck == sanityCheck)&&(identical(other.overallWeightedScore, overallWeightedScore) || other.overallWeightedScore == overallWeightedScore)&&(identical(other.overallLabel, overallLabel) || other.overallLabel == overallLabel)&&const DeepCollectionEquality().equals(other._priorityImprovements, _priorityImprovements)&&const DeepCollectionEquality().equals(other._highlights, _highlights));
}


@override
int get hashCode => Object.hash(runtimeType,structuredProblemSolving,businessJudgment,quantitativeSkills,communication,sanityCheck,overallWeightedScore,overallLabel,const DeepCollectionEquality().hash(_priorityImprovements),const DeepCollectionEquality().hash(_highlights));

@override
String toString() {
  return 'CaseAnalysis(structuredProblemSolving: $structuredProblemSolving, businessJudgment: $businessJudgment, quantitativeSkills: $quantitativeSkills, communication: $communication, sanityCheck: $sanityCheck, overallWeightedScore: $overallWeightedScore, overallLabel: $overallLabel, priorityImprovements: $priorityImprovements, highlights: $highlights)';
}


}

/// @nodoc
abstract mixin class _$CaseAnalysisCopyWith<$Res> implements $CaseAnalysisCopyWith<$Res> {
  factory _$CaseAnalysisCopyWith(_CaseAnalysis value, $Res Function(_CaseAnalysis) _then) = __$CaseAnalysisCopyWithImpl;
@override @useResult
$Res call({
 StructuredProblemSolving structuredProblemSolving, BusinessJudgment businessJudgment, QuantitativeSkills quantitativeSkills, Communication communication, SanityCheck sanityCheck, double overallWeightedScore, String overallLabel, List<PriorityImprovement> priorityImprovements, List<String> highlights
});


@override $StructuredProblemSolvingCopyWith<$Res> get structuredProblemSolving;@override $BusinessJudgmentCopyWith<$Res> get businessJudgment;@override $QuantitativeSkillsCopyWith<$Res> get quantitativeSkills;@override $CommunicationCopyWith<$Res> get communication;@override $SanityCheckCopyWith<$Res> get sanityCheck;

}
/// @nodoc
class __$CaseAnalysisCopyWithImpl<$Res>
    implements _$CaseAnalysisCopyWith<$Res> {
  __$CaseAnalysisCopyWithImpl(this._self, this._then);

  final _CaseAnalysis _self;
  final $Res Function(_CaseAnalysis) _then;

/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? structuredProblemSolving = null,Object? businessJudgment = null,Object? quantitativeSkills = null,Object? communication = null,Object? sanityCheck = null,Object? overallWeightedScore = null,Object? overallLabel = null,Object? priorityImprovements = null,Object? highlights = null,}) {
  return _then(_CaseAnalysis(
structuredProblemSolving: null == structuredProblemSolving ? _self.structuredProblemSolving : structuredProblemSolving // ignore: cast_nullable_to_non_nullable
as StructuredProblemSolving,businessJudgment: null == businessJudgment ? _self.businessJudgment : businessJudgment // ignore: cast_nullable_to_non_nullable
as BusinessJudgment,quantitativeSkills: null == quantitativeSkills ? _self.quantitativeSkills : quantitativeSkills // ignore: cast_nullable_to_non_nullable
as QuantitativeSkills,communication: null == communication ? _self.communication : communication // ignore: cast_nullable_to_non_nullable
as Communication,sanityCheck: null == sanityCheck ? _self.sanityCheck : sanityCheck // ignore: cast_nullable_to_non_nullable
as SanityCheck,overallWeightedScore: null == overallWeightedScore ? _self.overallWeightedScore : overallWeightedScore // ignore: cast_nullable_to_non_nullable
as double,overallLabel: null == overallLabel ? _self.overallLabel : overallLabel // ignore: cast_nullable_to_non_nullable
as String,priorityImprovements: null == priorityImprovements ? _self._priorityImprovements : priorityImprovements // ignore: cast_nullable_to_non_nullable
as List<PriorityImprovement>,highlights: null == highlights ? _self._highlights : highlights // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}

/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$StructuredProblemSolvingCopyWith<$Res> get structuredProblemSolving {
  
  return $StructuredProblemSolvingCopyWith<$Res>(_self.structuredProblemSolving, (value) {
    return _then(_self.copyWith(structuredProblemSolving: value));
  });
}/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$BusinessJudgmentCopyWith<$Res> get businessJudgment {
  
  return $BusinessJudgmentCopyWith<$Res>(_self.businessJudgment, (value) {
    return _then(_self.copyWith(businessJudgment: value));
  });
}/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$QuantitativeSkillsCopyWith<$Res> get quantitativeSkills {
  
  return $QuantitativeSkillsCopyWith<$Res>(_self.quantitativeSkills, (value) {
    return _then(_self.copyWith(quantitativeSkills: value));
  });
}/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommunicationCopyWith<$Res> get communication {
  
  return $CommunicationCopyWith<$Res>(_self.communication, (value) {
    return _then(_self.copyWith(communication: value));
  });
}/// Create a copy of CaseAnalysis
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SanityCheckCopyWith<$Res> get sanityCheck {
  
  return $SanityCheckCopyWith<$Res>(_self.sanityCheck, (value) {
    return _then(_self.copyWith(sanityCheck: value));
  });
}
}

/// @nodoc
mixin _$StructuredProblemSolving {

 int get score; String get feedback; String get frameworkDetected; bool get meceApplied; bool get clarifyingQuestionsAsked;
/// Create a copy of StructuredProblemSolving
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$StructuredProblemSolvingCopyWith<StructuredProblemSolving> get copyWith => _$StructuredProblemSolvingCopyWithImpl<StructuredProblemSolving>(this as StructuredProblemSolving, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is StructuredProblemSolving&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.frameworkDetected, frameworkDetected) || other.frameworkDetected == frameworkDetected)&&(identical(other.meceApplied, meceApplied) || other.meceApplied == meceApplied)&&(identical(other.clarifyingQuestionsAsked, clarifyingQuestionsAsked) || other.clarifyingQuestionsAsked == clarifyingQuestionsAsked));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,frameworkDetected,meceApplied,clarifyingQuestionsAsked);

@override
String toString() {
  return 'StructuredProblemSolving(score: $score, feedback: $feedback, frameworkDetected: $frameworkDetected, meceApplied: $meceApplied, clarifyingQuestionsAsked: $clarifyingQuestionsAsked)';
}


}

/// @nodoc
abstract mixin class $StructuredProblemSolvingCopyWith<$Res>  {
  factory $StructuredProblemSolvingCopyWith(StructuredProblemSolving value, $Res Function(StructuredProblemSolving) _then) = _$StructuredProblemSolvingCopyWithImpl;
@useResult
$Res call({
 int score, String feedback, String frameworkDetected, bool meceApplied, bool clarifyingQuestionsAsked
});




}
/// @nodoc
class _$StructuredProblemSolvingCopyWithImpl<$Res>
    implements $StructuredProblemSolvingCopyWith<$Res> {
  _$StructuredProblemSolvingCopyWithImpl(this._self, this._then);

  final StructuredProblemSolving _self;
  final $Res Function(StructuredProblemSolving) _then;

/// Create a copy of StructuredProblemSolving
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? score = null,Object? feedback = null,Object? frameworkDetected = null,Object? meceApplied = null,Object? clarifyingQuestionsAsked = null,}) {
  return _then(_self.copyWith(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,frameworkDetected: null == frameworkDetected ? _self.frameworkDetected : frameworkDetected // ignore: cast_nullable_to_non_nullable
as String,meceApplied: null == meceApplied ? _self.meceApplied : meceApplied // ignore: cast_nullable_to_non_nullable
as bool,clarifyingQuestionsAsked: null == clarifyingQuestionsAsked ? _self.clarifyingQuestionsAsked : clarifyingQuestionsAsked // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}


/// Adds pattern-matching-related methods to [StructuredProblemSolving].
extension StructuredProblemSolvingPatterns on StructuredProblemSolving {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _StructuredProblemSolving value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _StructuredProblemSolving() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _StructuredProblemSolving value)  $default,){
final _that = this;
switch (_that) {
case _StructuredProblemSolving():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _StructuredProblemSolving value)?  $default,){
final _that = this;
switch (_that) {
case _StructuredProblemSolving() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int score,  String feedback,  String frameworkDetected,  bool meceApplied,  bool clarifyingQuestionsAsked)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _StructuredProblemSolving() when $default != null:
return $default(_that.score,_that.feedback,_that.frameworkDetected,_that.meceApplied,_that.clarifyingQuestionsAsked);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int score,  String feedback,  String frameworkDetected,  bool meceApplied,  bool clarifyingQuestionsAsked)  $default,) {final _that = this;
switch (_that) {
case _StructuredProblemSolving():
return $default(_that.score,_that.feedback,_that.frameworkDetected,_that.meceApplied,_that.clarifyingQuestionsAsked);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int score,  String feedback,  String frameworkDetected,  bool meceApplied,  bool clarifyingQuestionsAsked)?  $default,) {final _that = this;
switch (_that) {
case _StructuredProblemSolving() when $default != null:
return $default(_that.score,_that.feedback,_that.frameworkDetected,_that.meceApplied,_that.clarifyingQuestionsAsked);case _:
  return null;

}
}

}

/// @nodoc


class _StructuredProblemSolving implements StructuredProblemSolving {
  const _StructuredProblemSolving({required this.score, required this.feedback, required this.frameworkDetected, required this.meceApplied, required this.clarifyingQuestionsAsked});
  

@override final  int score;
@override final  String feedback;
@override final  String frameworkDetected;
@override final  bool meceApplied;
@override final  bool clarifyingQuestionsAsked;

/// Create a copy of StructuredProblemSolving
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$StructuredProblemSolvingCopyWith<_StructuredProblemSolving> get copyWith => __$StructuredProblemSolvingCopyWithImpl<_StructuredProblemSolving>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _StructuredProblemSolving&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.frameworkDetected, frameworkDetected) || other.frameworkDetected == frameworkDetected)&&(identical(other.meceApplied, meceApplied) || other.meceApplied == meceApplied)&&(identical(other.clarifyingQuestionsAsked, clarifyingQuestionsAsked) || other.clarifyingQuestionsAsked == clarifyingQuestionsAsked));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,frameworkDetected,meceApplied,clarifyingQuestionsAsked);

@override
String toString() {
  return 'StructuredProblemSolving(score: $score, feedback: $feedback, frameworkDetected: $frameworkDetected, meceApplied: $meceApplied, clarifyingQuestionsAsked: $clarifyingQuestionsAsked)';
}


}

/// @nodoc
abstract mixin class _$StructuredProblemSolvingCopyWith<$Res> implements $StructuredProblemSolvingCopyWith<$Res> {
  factory _$StructuredProblemSolvingCopyWith(_StructuredProblemSolving value, $Res Function(_StructuredProblemSolving) _then) = __$StructuredProblemSolvingCopyWithImpl;
@override @useResult
$Res call({
 int score, String feedback, String frameworkDetected, bool meceApplied, bool clarifyingQuestionsAsked
});




}
/// @nodoc
class __$StructuredProblemSolvingCopyWithImpl<$Res>
    implements _$StructuredProblemSolvingCopyWith<$Res> {
  __$StructuredProblemSolvingCopyWithImpl(this._self, this._then);

  final _StructuredProblemSolving _self;
  final $Res Function(_StructuredProblemSolving) _then;

/// Create a copy of StructuredProblemSolving
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? score = null,Object? feedback = null,Object? frameworkDetected = null,Object? meceApplied = null,Object? clarifyingQuestionsAsked = null,}) {
  return _then(_StructuredProblemSolving(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,frameworkDetected: null == frameworkDetected ? _self.frameworkDetected : frameworkDetected // ignore: cast_nullable_to_non_nullable
as String,meceApplied: null == meceApplied ? _self.meceApplied : meceApplied // ignore: cast_nullable_to_non_nullable
as bool,clarifyingQuestionsAsked: null == clarifyingQuestionsAsked ? _self.clarifyingQuestionsAsked : clarifyingQuestionsAsked // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc
mixin _$BusinessJudgment {

 int get score; String get feedback; bool get assumptionsStated; bool get assumptionsJustified; String get assumptionQuality;
/// Create a copy of BusinessJudgment
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BusinessJudgmentCopyWith<BusinessJudgment> get copyWith => _$BusinessJudgmentCopyWithImpl<BusinessJudgment>(this as BusinessJudgment, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BusinessJudgment&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.assumptionsStated, assumptionsStated) || other.assumptionsStated == assumptionsStated)&&(identical(other.assumptionsJustified, assumptionsJustified) || other.assumptionsJustified == assumptionsJustified)&&(identical(other.assumptionQuality, assumptionQuality) || other.assumptionQuality == assumptionQuality));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,assumptionsStated,assumptionsJustified,assumptionQuality);

@override
String toString() {
  return 'BusinessJudgment(score: $score, feedback: $feedback, assumptionsStated: $assumptionsStated, assumptionsJustified: $assumptionsJustified, assumptionQuality: $assumptionQuality)';
}


}

/// @nodoc
abstract mixin class $BusinessJudgmentCopyWith<$Res>  {
  factory $BusinessJudgmentCopyWith(BusinessJudgment value, $Res Function(BusinessJudgment) _then) = _$BusinessJudgmentCopyWithImpl;
@useResult
$Res call({
 int score, String feedback, bool assumptionsStated, bool assumptionsJustified, String assumptionQuality
});




}
/// @nodoc
class _$BusinessJudgmentCopyWithImpl<$Res>
    implements $BusinessJudgmentCopyWith<$Res> {
  _$BusinessJudgmentCopyWithImpl(this._self, this._then);

  final BusinessJudgment _self;
  final $Res Function(BusinessJudgment) _then;

/// Create a copy of BusinessJudgment
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? score = null,Object? feedback = null,Object? assumptionsStated = null,Object? assumptionsJustified = null,Object? assumptionQuality = null,}) {
  return _then(_self.copyWith(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,assumptionsStated: null == assumptionsStated ? _self.assumptionsStated : assumptionsStated // ignore: cast_nullable_to_non_nullable
as bool,assumptionsJustified: null == assumptionsJustified ? _self.assumptionsJustified : assumptionsJustified // ignore: cast_nullable_to_non_nullable
as bool,assumptionQuality: null == assumptionQuality ? _self.assumptionQuality : assumptionQuality // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [BusinessJudgment].
extension BusinessJudgmentPatterns on BusinessJudgment {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _BusinessJudgment value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _BusinessJudgment() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _BusinessJudgment value)  $default,){
final _that = this;
switch (_that) {
case _BusinessJudgment():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _BusinessJudgment value)?  $default,){
final _that = this;
switch (_that) {
case _BusinessJudgment() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int score,  String feedback,  bool assumptionsStated,  bool assumptionsJustified,  String assumptionQuality)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _BusinessJudgment() when $default != null:
return $default(_that.score,_that.feedback,_that.assumptionsStated,_that.assumptionsJustified,_that.assumptionQuality);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int score,  String feedback,  bool assumptionsStated,  bool assumptionsJustified,  String assumptionQuality)  $default,) {final _that = this;
switch (_that) {
case _BusinessJudgment():
return $default(_that.score,_that.feedback,_that.assumptionsStated,_that.assumptionsJustified,_that.assumptionQuality);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int score,  String feedback,  bool assumptionsStated,  bool assumptionsJustified,  String assumptionQuality)?  $default,) {final _that = this;
switch (_that) {
case _BusinessJudgment() when $default != null:
return $default(_that.score,_that.feedback,_that.assumptionsStated,_that.assumptionsJustified,_that.assumptionQuality);case _:
  return null;

}
}

}

/// @nodoc


class _BusinessJudgment implements BusinessJudgment {
  const _BusinessJudgment({required this.score, required this.feedback, required this.assumptionsStated, required this.assumptionsJustified, required this.assumptionQuality});
  

@override final  int score;
@override final  String feedback;
@override final  bool assumptionsStated;
@override final  bool assumptionsJustified;
@override final  String assumptionQuality;

/// Create a copy of BusinessJudgment
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BusinessJudgmentCopyWith<_BusinessJudgment> get copyWith => __$BusinessJudgmentCopyWithImpl<_BusinessJudgment>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BusinessJudgment&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.assumptionsStated, assumptionsStated) || other.assumptionsStated == assumptionsStated)&&(identical(other.assumptionsJustified, assumptionsJustified) || other.assumptionsJustified == assumptionsJustified)&&(identical(other.assumptionQuality, assumptionQuality) || other.assumptionQuality == assumptionQuality));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,assumptionsStated,assumptionsJustified,assumptionQuality);

@override
String toString() {
  return 'BusinessJudgment(score: $score, feedback: $feedback, assumptionsStated: $assumptionsStated, assumptionsJustified: $assumptionsJustified, assumptionQuality: $assumptionQuality)';
}


}

/// @nodoc
abstract mixin class _$BusinessJudgmentCopyWith<$Res> implements $BusinessJudgmentCopyWith<$Res> {
  factory _$BusinessJudgmentCopyWith(_BusinessJudgment value, $Res Function(_BusinessJudgment) _then) = __$BusinessJudgmentCopyWithImpl;
@override @useResult
$Res call({
 int score, String feedback, bool assumptionsStated, bool assumptionsJustified, String assumptionQuality
});




}
/// @nodoc
class __$BusinessJudgmentCopyWithImpl<$Res>
    implements _$BusinessJudgmentCopyWith<$Res> {
  __$BusinessJudgmentCopyWithImpl(this._self, this._then);

  final _BusinessJudgment _self;
  final $Res Function(_BusinessJudgment) _then;

/// Create a copy of BusinessJudgment
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? score = null,Object? feedback = null,Object? assumptionsStated = null,Object? assumptionsJustified = null,Object? assumptionQuality = null,}) {
  return _then(_BusinessJudgment(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,assumptionsStated: null == assumptionsStated ? _self.assumptionsStated : assumptionsStated // ignore: cast_nullable_to_non_nullable
as bool,assumptionsJustified: null == assumptionsJustified ? _self.assumptionsJustified : assumptionsJustified // ignore: cast_nullable_to_non_nullable
as bool,assumptionQuality: null == assumptionQuality ? _self.assumptionQuality : assumptionQuality // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$QuantitativeSkills {

 int get score; String get feedback; bool get mathShownStepByStep; bool get mathVerbalized; bool get calculationsAccurate;
/// Create a copy of QuantitativeSkills
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$QuantitativeSkillsCopyWith<QuantitativeSkills> get copyWith => _$QuantitativeSkillsCopyWithImpl<QuantitativeSkills>(this as QuantitativeSkills, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is QuantitativeSkills&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.mathShownStepByStep, mathShownStepByStep) || other.mathShownStepByStep == mathShownStepByStep)&&(identical(other.mathVerbalized, mathVerbalized) || other.mathVerbalized == mathVerbalized)&&(identical(other.calculationsAccurate, calculationsAccurate) || other.calculationsAccurate == calculationsAccurate));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,mathShownStepByStep,mathVerbalized,calculationsAccurate);

@override
String toString() {
  return 'QuantitativeSkills(score: $score, feedback: $feedback, mathShownStepByStep: $mathShownStepByStep, mathVerbalized: $mathVerbalized, calculationsAccurate: $calculationsAccurate)';
}


}

/// @nodoc
abstract mixin class $QuantitativeSkillsCopyWith<$Res>  {
  factory $QuantitativeSkillsCopyWith(QuantitativeSkills value, $Res Function(QuantitativeSkills) _then) = _$QuantitativeSkillsCopyWithImpl;
@useResult
$Res call({
 int score, String feedback, bool mathShownStepByStep, bool mathVerbalized, bool calculationsAccurate
});




}
/// @nodoc
class _$QuantitativeSkillsCopyWithImpl<$Res>
    implements $QuantitativeSkillsCopyWith<$Res> {
  _$QuantitativeSkillsCopyWithImpl(this._self, this._then);

  final QuantitativeSkills _self;
  final $Res Function(QuantitativeSkills) _then;

/// Create a copy of QuantitativeSkills
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? score = null,Object? feedback = null,Object? mathShownStepByStep = null,Object? mathVerbalized = null,Object? calculationsAccurate = null,}) {
  return _then(_self.copyWith(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,mathShownStepByStep: null == mathShownStepByStep ? _self.mathShownStepByStep : mathShownStepByStep // ignore: cast_nullable_to_non_nullable
as bool,mathVerbalized: null == mathVerbalized ? _self.mathVerbalized : mathVerbalized // ignore: cast_nullable_to_non_nullable
as bool,calculationsAccurate: null == calculationsAccurate ? _self.calculationsAccurate : calculationsAccurate // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}


/// Adds pattern-matching-related methods to [QuantitativeSkills].
extension QuantitativeSkillsPatterns on QuantitativeSkills {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _QuantitativeSkills value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _QuantitativeSkills() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _QuantitativeSkills value)  $default,){
final _that = this;
switch (_that) {
case _QuantitativeSkills():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _QuantitativeSkills value)?  $default,){
final _that = this;
switch (_that) {
case _QuantitativeSkills() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int score,  String feedback,  bool mathShownStepByStep,  bool mathVerbalized,  bool calculationsAccurate)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _QuantitativeSkills() when $default != null:
return $default(_that.score,_that.feedback,_that.mathShownStepByStep,_that.mathVerbalized,_that.calculationsAccurate);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int score,  String feedback,  bool mathShownStepByStep,  bool mathVerbalized,  bool calculationsAccurate)  $default,) {final _that = this;
switch (_that) {
case _QuantitativeSkills():
return $default(_that.score,_that.feedback,_that.mathShownStepByStep,_that.mathVerbalized,_that.calculationsAccurate);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int score,  String feedback,  bool mathShownStepByStep,  bool mathVerbalized,  bool calculationsAccurate)?  $default,) {final _that = this;
switch (_that) {
case _QuantitativeSkills() when $default != null:
return $default(_that.score,_that.feedback,_that.mathShownStepByStep,_that.mathVerbalized,_that.calculationsAccurate);case _:
  return null;

}
}

}

/// @nodoc


class _QuantitativeSkills implements QuantitativeSkills {
  const _QuantitativeSkills({required this.score, required this.feedback, required this.mathShownStepByStep, required this.mathVerbalized, required this.calculationsAccurate});
  

@override final  int score;
@override final  String feedback;
@override final  bool mathShownStepByStep;
@override final  bool mathVerbalized;
@override final  bool calculationsAccurate;

/// Create a copy of QuantitativeSkills
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$QuantitativeSkillsCopyWith<_QuantitativeSkills> get copyWith => __$QuantitativeSkillsCopyWithImpl<_QuantitativeSkills>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _QuantitativeSkills&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.mathShownStepByStep, mathShownStepByStep) || other.mathShownStepByStep == mathShownStepByStep)&&(identical(other.mathVerbalized, mathVerbalized) || other.mathVerbalized == mathVerbalized)&&(identical(other.calculationsAccurate, calculationsAccurate) || other.calculationsAccurate == calculationsAccurate));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,mathShownStepByStep,mathVerbalized,calculationsAccurate);

@override
String toString() {
  return 'QuantitativeSkills(score: $score, feedback: $feedback, mathShownStepByStep: $mathShownStepByStep, mathVerbalized: $mathVerbalized, calculationsAccurate: $calculationsAccurate)';
}


}

/// @nodoc
abstract mixin class _$QuantitativeSkillsCopyWith<$Res> implements $QuantitativeSkillsCopyWith<$Res> {
  factory _$QuantitativeSkillsCopyWith(_QuantitativeSkills value, $Res Function(_QuantitativeSkills) _then) = __$QuantitativeSkillsCopyWithImpl;
@override @useResult
$Res call({
 int score, String feedback, bool mathShownStepByStep, bool mathVerbalized, bool calculationsAccurate
});




}
/// @nodoc
class __$QuantitativeSkillsCopyWithImpl<$Res>
    implements _$QuantitativeSkillsCopyWith<$Res> {
  __$QuantitativeSkillsCopyWithImpl(this._self, this._then);

  final _QuantitativeSkills _self;
  final $Res Function(_QuantitativeSkills) _then;

/// Create a copy of QuantitativeSkills
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? score = null,Object? feedback = null,Object? mathShownStepByStep = null,Object? mathVerbalized = null,Object? calculationsAccurate = null,}) {
  return _then(_QuantitativeSkills(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,mathShownStepByStep: null == mathShownStepByStep ? _self.mathShownStepByStep : mathShownStepByStep // ignore: cast_nullable_to_non_nullable
as bool,mathVerbalized: null == mathVerbalized ? _self.mathVerbalized : mathVerbalized // ignore: cast_nullable_to_non_nullable
as bool,calculationsAccurate: null == calculationsAccurate ? _self.calculationsAccurate : calculationsAccurate // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc
mixin _$Communication {

 int get score; String get feedback; String? get paceAnalysis; int? get fillersCount; int? get pausesCount;
/// Create a copy of Communication
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CommunicationCopyWith<Communication> get copyWith => _$CommunicationCopyWithImpl<Communication>(this as Communication, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Communication&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.paceAnalysis, paceAnalysis) || other.paceAnalysis == paceAnalysis)&&(identical(other.fillersCount, fillersCount) || other.fillersCount == fillersCount)&&(identical(other.pausesCount, pausesCount) || other.pausesCount == pausesCount));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,paceAnalysis,fillersCount,pausesCount);

@override
String toString() {
  return 'Communication(score: $score, feedback: $feedback, paceAnalysis: $paceAnalysis, fillersCount: $fillersCount, pausesCount: $pausesCount)';
}


}

/// @nodoc
abstract mixin class $CommunicationCopyWith<$Res>  {
  factory $CommunicationCopyWith(Communication value, $Res Function(Communication) _then) = _$CommunicationCopyWithImpl;
@useResult
$Res call({
 int score, String feedback, String? paceAnalysis, int? fillersCount, int? pausesCount
});




}
/// @nodoc
class _$CommunicationCopyWithImpl<$Res>
    implements $CommunicationCopyWith<$Res> {
  _$CommunicationCopyWithImpl(this._self, this._then);

  final Communication _self;
  final $Res Function(Communication) _then;

/// Create a copy of Communication
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? score = null,Object? feedback = null,Object? paceAnalysis = freezed,Object? fillersCount = freezed,Object? pausesCount = freezed,}) {
  return _then(_self.copyWith(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,paceAnalysis: freezed == paceAnalysis ? _self.paceAnalysis : paceAnalysis // ignore: cast_nullable_to_non_nullable
as String?,fillersCount: freezed == fillersCount ? _self.fillersCount : fillersCount // ignore: cast_nullable_to_non_nullable
as int?,pausesCount: freezed == pausesCount ? _self.pausesCount : pausesCount // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// Adds pattern-matching-related methods to [Communication].
extension CommunicationPatterns on Communication {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _Communication value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _Communication() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _Communication value)  $default,){
final _that = this;
switch (_that) {
case _Communication():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _Communication value)?  $default,){
final _that = this;
switch (_that) {
case _Communication() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int score,  String feedback,  String? paceAnalysis,  int? fillersCount,  int? pausesCount)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _Communication() when $default != null:
return $default(_that.score,_that.feedback,_that.paceAnalysis,_that.fillersCount,_that.pausesCount);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int score,  String feedback,  String? paceAnalysis,  int? fillersCount,  int? pausesCount)  $default,) {final _that = this;
switch (_that) {
case _Communication():
return $default(_that.score,_that.feedback,_that.paceAnalysis,_that.fillersCount,_that.pausesCount);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int score,  String feedback,  String? paceAnalysis,  int? fillersCount,  int? pausesCount)?  $default,) {final _that = this;
switch (_that) {
case _Communication() when $default != null:
return $default(_that.score,_that.feedback,_that.paceAnalysis,_that.fillersCount,_that.pausesCount);case _:
  return null;

}
}

}

/// @nodoc


class _Communication implements Communication {
  const _Communication({required this.score, required this.feedback, this.paceAnalysis, this.fillersCount, this.pausesCount});
  

@override final  int score;
@override final  String feedback;
@override final  String? paceAnalysis;
@override final  int? fillersCount;
@override final  int? pausesCount;

/// Create a copy of Communication
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CommunicationCopyWith<_Communication> get copyWith => __$CommunicationCopyWithImpl<_Communication>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Communication&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.paceAnalysis, paceAnalysis) || other.paceAnalysis == paceAnalysis)&&(identical(other.fillersCount, fillersCount) || other.fillersCount == fillersCount)&&(identical(other.pausesCount, pausesCount) || other.pausesCount == pausesCount));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,paceAnalysis,fillersCount,pausesCount);

@override
String toString() {
  return 'Communication(score: $score, feedback: $feedback, paceAnalysis: $paceAnalysis, fillersCount: $fillersCount, pausesCount: $pausesCount)';
}


}

/// @nodoc
abstract mixin class _$CommunicationCopyWith<$Res> implements $CommunicationCopyWith<$Res> {
  factory _$CommunicationCopyWith(_Communication value, $Res Function(_Communication) _then) = __$CommunicationCopyWithImpl;
@override @useResult
$Res call({
 int score, String feedback, String? paceAnalysis, int? fillersCount, int? pausesCount
});




}
/// @nodoc
class __$CommunicationCopyWithImpl<$Res>
    implements _$CommunicationCopyWith<$Res> {
  __$CommunicationCopyWithImpl(this._self, this._then);

  final _Communication _self;
  final $Res Function(_Communication) _then;

/// Create a copy of Communication
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? score = null,Object? feedback = null,Object? paceAnalysis = freezed,Object? fillersCount = freezed,Object? pausesCount = freezed,}) {
  return _then(_Communication(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,paceAnalysis: freezed == paceAnalysis ? _self.paceAnalysis : paceAnalysis // ignore: cast_nullable_to_non_nullable
as String?,fillersCount: freezed == fillersCount ? _self.fillersCount : fillersCount // ignore: cast_nullable_to_non_nullable
as int?,pausesCount: freezed == pausesCount ? _self.pausesCount : pausesCount // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

/// @nodoc
mixin _$SanityCheck {

 int get score; String get feedback; bool get sanityCheckPerformed; bool get sanityCheckVerbalized;
/// Create a copy of SanityCheck
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SanityCheckCopyWith<SanityCheck> get copyWith => _$SanityCheckCopyWithImpl<SanityCheck>(this as SanityCheck, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SanityCheck&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.sanityCheckPerformed, sanityCheckPerformed) || other.sanityCheckPerformed == sanityCheckPerformed)&&(identical(other.sanityCheckVerbalized, sanityCheckVerbalized) || other.sanityCheckVerbalized == sanityCheckVerbalized));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,sanityCheckPerformed,sanityCheckVerbalized);

@override
String toString() {
  return 'SanityCheck(score: $score, feedback: $feedback, sanityCheckPerformed: $sanityCheckPerformed, sanityCheckVerbalized: $sanityCheckVerbalized)';
}


}

/// @nodoc
abstract mixin class $SanityCheckCopyWith<$Res>  {
  factory $SanityCheckCopyWith(SanityCheck value, $Res Function(SanityCheck) _then) = _$SanityCheckCopyWithImpl;
@useResult
$Res call({
 int score, String feedback, bool sanityCheckPerformed, bool sanityCheckVerbalized
});




}
/// @nodoc
class _$SanityCheckCopyWithImpl<$Res>
    implements $SanityCheckCopyWith<$Res> {
  _$SanityCheckCopyWithImpl(this._self, this._then);

  final SanityCheck _self;
  final $Res Function(SanityCheck) _then;

/// Create a copy of SanityCheck
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? score = null,Object? feedback = null,Object? sanityCheckPerformed = null,Object? sanityCheckVerbalized = null,}) {
  return _then(_self.copyWith(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,sanityCheckPerformed: null == sanityCheckPerformed ? _self.sanityCheckPerformed : sanityCheckPerformed // ignore: cast_nullable_to_non_nullable
as bool,sanityCheckVerbalized: null == sanityCheckVerbalized ? _self.sanityCheckVerbalized : sanityCheckVerbalized // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}


/// Adds pattern-matching-related methods to [SanityCheck].
extension SanityCheckPatterns on SanityCheck {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _SanityCheck value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _SanityCheck() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _SanityCheck value)  $default,){
final _that = this;
switch (_that) {
case _SanityCheck():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _SanityCheck value)?  $default,){
final _that = this;
switch (_that) {
case _SanityCheck() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int score,  String feedback,  bool sanityCheckPerformed,  bool sanityCheckVerbalized)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _SanityCheck() when $default != null:
return $default(_that.score,_that.feedback,_that.sanityCheckPerformed,_that.sanityCheckVerbalized);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int score,  String feedback,  bool sanityCheckPerformed,  bool sanityCheckVerbalized)  $default,) {final _that = this;
switch (_that) {
case _SanityCheck():
return $default(_that.score,_that.feedback,_that.sanityCheckPerformed,_that.sanityCheckVerbalized);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int score,  String feedback,  bool sanityCheckPerformed,  bool sanityCheckVerbalized)?  $default,) {final _that = this;
switch (_that) {
case _SanityCheck() when $default != null:
return $default(_that.score,_that.feedback,_that.sanityCheckPerformed,_that.sanityCheckVerbalized);case _:
  return null;

}
}

}

/// @nodoc


class _SanityCheck implements SanityCheck {
  const _SanityCheck({required this.score, required this.feedback, required this.sanityCheckPerformed, required this.sanityCheckVerbalized});
  

@override final  int score;
@override final  String feedback;
@override final  bool sanityCheckPerformed;
@override final  bool sanityCheckVerbalized;

/// Create a copy of SanityCheck
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SanityCheckCopyWith<_SanityCheck> get copyWith => __$SanityCheckCopyWithImpl<_SanityCheck>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SanityCheck&&(identical(other.score, score) || other.score == score)&&(identical(other.feedback, feedback) || other.feedback == feedback)&&(identical(other.sanityCheckPerformed, sanityCheckPerformed) || other.sanityCheckPerformed == sanityCheckPerformed)&&(identical(other.sanityCheckVerbalized, sanityCheckVerbalized) || other.sanityCheckVerbalized == sanityCheckVerbalized));
}


@override
int get hashCode => Object.hash(runtimeType,score,feedback,sanityCheckPerformed,sanityCheckVerbalized);

@override
String toString() {
  return 'SanityCheck(score: $score, feedback: $feedback, sanityCheckPerformed: $sanityCheckPerformed, sanityCheckVerbalized: $sanityCheckVerbalized)';
}


}

/// @nodoc
abstract mixin class _$SanityCheckCopyWith<$Res> implements $SanityCheckCopyWith<$Res> {
  factory _$SanityCheckCopyWith(_SanityCheck value, $Res Function(_SanityCheck) _then) = __$SanityCheckCopyWithImpl;
@override @useResult
$Res call({
 int score, String feedback, bool sanityCheckPerformed, bool sanityCheckVerbalized
});




}
/// @nodoc
class __$SanityCheckCopyWithImpl<$Res>
    implements _$SanityCheckCopyWith<$Res> {
  __$SanityCheckCopyWithImpl(this._self, this._then);

  final _SanityCheck _self;
  final $Res Function(_SanityCheck) _then;

/// Create a copy of SanityCheck
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? score = null,Object? feedback = null,Object? sanityCheckPerformed = null,Object? sanityCheckVerbalized = null,}) {
  return _then(_SanityCheck(
score: null == score ? _self.score : score // ignore: cast_nullable_to_non_nullable
as int,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,sanityCheckPerformed: null == sanityCheckPerformed ? _self.sanityCheckPerformed : sanityCheckPerformed // ignore: cast_nullable_to_non_nullable
as bool,sanityCheckVerbalized: null == sanityCheckVerbalized ? _self.sanityCheckVerbalized : sanityCheckVerbalized // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc
mixin _$PriorityImprovement {

 String get timestamp; String get feedback;
/// Create a copy of PriorityImprovement
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PriorityImprovementCopyWith<PriorityImprovement> get copyWith => _$PriorityImprovementCopyWithImpl<PriorityImprovement>(this as PriorityImprovement, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PriorityImprovement&&(identical(other.timestamp, timestamp) || other.timestamp == timestamp)&&(identical(other.feedback, feedback) || other.feedback == feedback));
}


@override
int get hashCode => Object.hash(runtimeType,timestamp,feedback);

@override
String toString() {
  return 'PriorityImprovement(timestamp: $timestamp, feedback: $feedback)';
}


}

/// @nodoc
abstract mixin class $PriorityImprovementCopyWith<$Res>  {
  factory $PriorityImprovementCopyWith(PriorityImprovement value, $Res Function(PriorityImprovement) _then) = _$PriorityImprovementCopyWithImpl;
@useResult
$Res call({
 String timestamp, String feedback
});




}
/// @nodoc
class _$PriorityImprovementCopyWithImpl<$Res>
    implements $PriorityImprovementCopyWith<$Res> {
  _$PriorityImprovementCopyWithImpl(this._self, this._then);

  final PriorityImprovement _self;
  final $Res Function(PriorityImprovement) _then;

/// Create a copy of PriorityImprovement
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? timestamp = null,Object? feedback = null,}) {
  return _then(_self.copyWith(
timestamp: null == timestamp ? _self.timestamp : timestamp // ignore: cast_nullable_to_non_nullable
as String,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [PriorityImprovement].
extension PriorityImprovementPatterns on PriorityImprovement {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _PriorityImprovement value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _PriorityImprovement() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _PriorityImprovement value)  $default,){
final _that = this;
switch (_that) {
case _PriorityImprovement():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _PriorityImprovement value)?  $default,){
final _that = this;
switch (_that) {
case _PriorityImprovement() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String timestamp,  String feedback)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _PriorityImprovement() when $default != null:
return $default(_that.timestamp,_that.feedback);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String timestamp,  String feedback)  $default,) {final _that = this;
switch (_that) {
case _PriorityImprovement():
return $default(_that.timestamp,_that.feedback);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String timestamp,  String feedback)?  $default,) {final _that = this;
switch (_that) {
case _PriorityImprovement() when $default != null:
return $default(_that.timestamp,_that.feedback);case _:
  return null;

}
}

}

/// @nodoc


class _PriorityImprovement implements PriorityImprovement {
  const _PriorityImprovement({required this.timestamp, required this.feedback});
  

@override final  String timestamp;
@override final  String feedback;

/// Create a copy of PriorityImprovement
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PriorityImprovementCopyWith<_PriorityImprovement> get copyWith => __$PriorityImprovementCopyWithImpl<_PriorityImprovement>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PriorityImprovement&&(identical(other.timestamp, timestamp) || other.timestamp == timestamp)&&(identical(other.feedback, feedback) || other.feedback == feedback));
}


@override
int get hashCode => Object.hash(runtimeType,timestamp,feedback);

@override
String toString() {
  return 'PriorityImprovement(timestamp: $timestamp, feedback: $feedback)';
}


}

/// @nodoc
abstract mixin class _$PriorityImprovementCopyWith<$Res> implements $PriorityImprovementCopyWith<$Res> {
  factory _$PriorityImprovementCopyWith(_PriorityImprovement value, $Res Function(_PriorityImprovement) _then) = __$PriorityImprovementCopyWithImpl;
@override @useResult
$Res call({
 String timestamp, String feedback
});




}
/// @nodoc
class __$PriorityImprovementCopyWithImpl<$Res>
    implements _$PriorityImprovementCopyWith<$Res> {
  __$PriorityImprovementCopyWithImpl(this._self, this._then);

  final _PriorityImprovement _self;
  final $Res Function(_PriorityImprovement) _then;

/// Create a copy of PriorityImprovement
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? timestamp = null,Object? feedback = null,}) {
  return _then(_PriorityImprovement(
timestamp: null == timestamp ? _self.timestamp : timestamp // ignore: cast_nullable_to_non_nullable
as String,feedback: null == feedback ? _self.feedback : feedback // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
